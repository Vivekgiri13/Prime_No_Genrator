# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m_vG2sGlb9T428uKCQwMcXHRMm3f_CJH
"""



from datetime import datetime
import sys


def sieve_of_eratosthenes(start, end):
    # Create a boolean array "is_prime[0..n]" and initialize
    # all entries it as true. A value in is_prime[i] will
    # finally be false if i is Not a prime, else true.
    n = end + 1
    is_prime = [True] * n
    primes = []

    # Loop through all numbers up to the square root of n
    for p in range(2, int(n ** 0.5) + 1):
        # If p is prime, mark all its multiples as not prime
        if is_prime[p]:
            for i in range(p ** 2, n, p):
                is_prime[i] = False

    # Append all prime numbers in the given range to the primes list
    for p in range(max(start, 2), n):
        if is_prime[p]:
            primes.append(p)

    return primes


def sieve_of_sundaram(start, end):
    # If Invalid input
    if start < 2:
        start = 2
    if end < start:
        return []

    k = 2 * end + 1
    n = (k - 2) // 2
    sieve = [False] * (n + 1)

    for i in range(1, n + 1):
        j = i
        while i + j + 2 * i * j <= n:
            sieve[i + j + 2 * i * j] = True
            j += 1

    primes = [2] + [2 * i + 1 for i in range(1, n + 1) if not sieve[i]]
    primes_between_a_b = [p for p in primes if p >= start and p <= end]
    return primes_between_a_b




def sieve_of_atkin(start,end):
    is_prime = [False] * (end - start + 1)
    # upto square root of n
    limit = int(end ** 0.5) + 1
    primes = []
    for i in range(2, limit):
        if all(i % j != 0 for j in range(2, int(i ** 0.5) + 1)):
            primes.append(i)
    #  mark all prime numbers between start and end
    for p in primes:
        q = p ** 2
        while q <= end:
            r = q - start % q
            if start % q == 0:
                r = 0
            while r <= end - start:
                is_prime[r] |= True
                r += q
    
    # Append to the primes list
    primes = [i + start for i in range(end - start + 1) if not is_prime[i]]
    return primes

def get_primes(start, end, algorithm):
    if start < 0 or end < 0 or end < start:
        print('invalid input')
    if algorithm not in ['eratosthenes', 'sundaram', 'atkin']:
        print('invalid input')

    if algorithm == 'eratosthenes':
        primes = sieve_of_eratosthenes(start,end)
        t2 = datetime.utcnow()
    elif algorithm == 'sundaram':
        primes=sieve_of_sundaram(start,end)
    else:
        primes = sieve_of_atkin(start,end)
        t2 = datetime.utcnow()
    primes_in_range = [p for p in primes if p >= start and p <= end]
    num_primes = len(primes_in_range)
    print( num_primes, primes_in_range)
start = int(sys.argv[1])
end = int(sys.argv[2])
algo = str(sys.argv[3])

    
# Call the sieve_of_atkin function and print the result
get_primes(start, end , algo)