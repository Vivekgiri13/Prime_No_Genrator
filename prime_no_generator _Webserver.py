# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m_vG2sGlb9T428uKCQwMcXHRMm3f_CJH
"""

from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

app = Flask('__main__')
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///primes.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

class Execution(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    range_start = db.Column(db.Integer, nullable=False)
    range_end = db.Column(db.Integer, nullable=False)
    algorithm = db.Column(db.String(50), nullable=False)
    num_primes = db.Column(db.Integer, nullable=False)
    time_elapsed = db.Column(db.Float, nullable=False)

    def __repr__(self):
        return f"Execution(timestamp='{self.timestamp}', range_start='{self.range_start}', range_end='{self.range_end}', algorithm='{self.algorithm}', num_primes='{self.num_primes}', time_elapsed='{self.time_elapsed}')"

def sieve_of_eratosthenes(n):
    n = end + 1
    noisprime = [True] * n
    primes = []

    for p in range(2, int(n**0.5)+1):
        # If p is prime than  multiples as not prime
        if noisprime[p]:
            for i in range(p**2, n, p):
                is_prime[i] = False

    for p in range(max(start, 2), n):
        if is_prime[p]:
            primes.append(p)

    return primes

def sieve_of_sundaram(n):
    n = (end - start) // 2
    is_prime = [True] * (n + 1)
    primes = []
    for j in range(1, n+1):
        for k in range(j, (n-j)//(2*j)+1):
            index = j + k + 2*j*k
            if index <= n:
                is_prime[index] = False

    for i in range(len(is_prime)):
        if is_prime[i] and (2*i+1) >= start and (2*i+1) <= end:
            primes.append(2*i+1)
    return primes
def sieve_of_atkin(n):
    is_prime = [False] * (end - start + 1)
    limit = int(end ** 0.5) + 1
    primes = []
    for i in range(2, limit):
        if all(i % j != 0 for j in range(2, int(i ** 0.5) + 1)):
            primes.append(i)
    for p in primes:
        q = p ** 2
        while q <= end:
            r = q - start % q
            if start % q == 0:
                r = 0
            while r <= end - start:
                is_prime[r] |= True
                r += q
    primes = [i + start for i in range(end - start + 1) if not is_prime[i]]
    return primes

@app.route('/primes/<int:start>/<int:end>/<string:algorithm>')
def get_primes(start, end, algorithm):
    if start < 0 or end < 0 or end < start:
        return jsonify({'error': 'Invalid input'}), 400
    if algorithm not in ['eratosthenes', 'sundaram', 'atkin']:
        return jsonify({'error': 'Invalid algorithm'}), 400
    t1 = datetime.utcnow()
    if algorithm == 'eratosthenes':
        primes = sieve_of_eratosthenes(end)
    elif algorithm == 'sundaram':
        primes = sieve_of_sundaram(end)
    else:
        primes = sieve_of_atkin(end)
    primes_in_range = [p for p in primes if p >= start and p <= end]
    t2 = datetime.utcnow()
    execution_time = (t2 - t1).total_seconds()
    num_primes = len(primes_in_range)
    with app.app_context():
      execution = Execution(range_start=start, range_end=end, algorithm=algorithm, num_primes=num_primes, time_elapsed=execution_time)
      db.session.add(execution)
      db.session.commit()
    return jsonify({'primes': primes_in_range})

if __name__ == '__main__':
  with app.app_context():
    db.create_all()
    app.run(host= '127.0.0.1', port = '5000' ,debug=True)
    executions = Execution.query.all()
    for e in executions:
        print(e)